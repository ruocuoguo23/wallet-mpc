# 安全素数生成优化方案

## 什么是安全素数？

**安全素数**（Safe Prime）是指满足 `p = 2q + 1` 的素数，其中 `q` 也是素数（称为 Sophie Germain 素数）。

例如：
- `q = 5` 是素数，`p = 2×5 + 1 = 11` 也是素数 → 11 是安全素数
- `q = 11` 是素数，`p = 2×11 + 1 = 23` 也是素数 → 23 是安全素数

安全素数在密码学中非常重要，特别是 Paillier 加密系统需要两个大的安全素数（通常 1536 位）。

---

## 原始算法及其问题

### 原始算法流程（逐个试除法）

```
循环:
    1. 生成一个随机奇数 x
    2. 对每个小素数 p，检查 (2x+1) % p == 0？
       如果是，x 不行，回到步骤 1
    3. 用 Miller-Rabin 测试 x 是否为素数
    4. 用 Miller-Rabin 测试 2x+1 是否为素数
    5. 如果都通过，返回 2x+1
```

### 存在的问题

1. **大数取模太多**：每生成一个候选数，都要做 `amount` 次大数取模（`x % p`），非常耗时
2. **筛选不充分**：只检查了 `2x+1`，没检查 `x` 本身
3. **利用率低**：虽然缓存了 20 万个小素数，但只敢用前 135 个（用多了更慢）

---

## 优化后的算法

我们的优化方案包含三个关键改进点，它们相互配合，共同实现了 10 倍以上的性能提升。

### 优化后的算法流程

```
1. 初始化：
   - 生成基数 base（随机大奇数）
   - 对每个小素数 p，计算初始偏移量 offsets[]（唯一的大数取模）

2. 批量筛选当前窗口：
   - 建立筛表 sieve[0..500000]
   - 用 offsets[] 批量标记所有能被小素数整除的位置（同时筛 x 和 2x+1）

3. 检验候选数：
   - 遍历筛表，对未被标记的候选数做 Miller-Rabin 测试
   - 找到则返回

4. 滑动窗口：
   - 如果没找到，base += 2 × SIEVE_SIZE
   - 增量更新 offsets[]（无需大数运算）
   - 回到步骤 2
```

---

## 三个关键改进点

### 改进点一：批量筛法

**核心思想**：不要一个一个检查，而是一次性检查一批！

**类比**：
- 原始方法：每次抽一张彩票，检查是否中奖
- 筛法：一次买 50 万张彩票，批量划掉不可能中奖的，只检查剩下的

**实现方式**：
```
建立筛表 sieve[0..500000]，代表候选数：
  sieve[0] → base
  sieve[1] → base + 2
  sieve[2] → base + 4
  ...
  sieve[k] → base + 2k

对于每个小素数 p：
  - 计算 base % p（只做一次大数取模！）
  - 用数学公式算出哪些 k 对应的候选数能被 p 整除
  - 把这些位置标记为 true（合数）
```

**效果**：

| 操作 | 原始方法 | 批量筛法 |
|------|----------|----------|
| 大数取模次数 | 每个候选数 × 135 次 | 每个窗口 × 30 万次（分摊到 50 万候选数） |
| 每个候选数的取模次数 | 135 次 | **0.6 次**（平均） |

---

### 改进点二：同时筛选 q 和 2q+1

**核心思想**：安全素数 `p = 2q + 1` 需要 `q` 和 `p` 都是素数。原算法只筛选 `2q+1`，我们同时筛选两者，过滤更彻底。

**筛选条件**：对于候选数 `x = base + 2k`：
1. **筛选 x**：如果 `x % p == 0`，则 `x` 是合数，标记
2. **筛选 2x+1**：如果 `(2x+1) % p == 0`，则 `2x+1` 是合数，标记

**数学推导**：

已知 `base % p = rem`，求哪些 `k` 使得 `(base + 2k) % p == 0`？

```
base + 2k ≡ 0 (mod p)
2k ≡ -rem (mod p)
k ≡ -rem × inv(2) (mod p)
```

其中 `inv(2) = (p + 1) / 2`（2 在模 p 下的逆元）

**例子**：`p = 7`，`rem = base % 7 = 3`
```
k ≡ -3 × inv(2) (mod 7)
k ≡ 4 × 4 (mod 7)     // -3 mod 7 = 4, inv(2) mod 7 = 4
k ≡ 16 mod 7 = 2
```
所以 `k = 2, 9, 16, 23, ...` 对应的 `x` 都能被 7 整除。

**图示**：假设 `SIEVE_SIZE = 20`，`p = 7`，起始偏移 `k = 2`：

```
索引 k:     0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
候选数:    base  base+2  base+4  ...
被7整除:         ✗           ✗              ✗              ✗
                 ↑           ↑              ↑              ↑
                k=2        k=9           k=16          k=23(下个窗口)
```

---

### 改进点三：滑动窗口与偏移量增量更新

**核心思想**：批量筛法的瓶颈是每次生成新的 `base` 都要对 30 万个小素数做一次大数取模。我们通过滑动窗口，让偏移量可以增量更新，避免重复的大数运算。

**关键洞察**：窗口前移后，偏移量可以增量更新，无需重新计算！

```rust
// 筛选当前窗口
let mut k = offsets_x[i];
while k < SIEVE_SIZE {
    sieve[k] = true;
    k += p;
}
// 保存下一窗口的起始偏移（不需要大数运算！）
offsets_x[i] = k - SIEVE_SIZE;
```

**例子**：`p = 7`，`SIEVE_SIZE = 20`，当前 `offsets_x[i] = 2`

```
当前窗口：k = 2, 9, 16, 23 → 标记 2, 9, 16
           23 超出窗口，保存 offsets_x[i] = 23 - 20 = 3

下一窗口：从 k = 3 开始 → 标记 3, 10, 17
           24 超出窗口，保存 offsets_x[i] = 24 - 20 = 4
```

**效果**：

| 场景 | 大数取模次数 |
|------|--------------|
| 原始方法 | 每个候选数 × 135 |
| 批量筛法 | 每个窗口 × 30 万 |
| 滑动窗口 | **只在初始化和重置时** |

滑动窗口将大数取模的开销分摊到多个窗口中，筛选过程几乎只有内存访问和整数加法。

---

## 参数配置

```rust
// 使用 30 万个小素数进行筛选
const AMOUNT: usize = 300_000;

// 每个窗口检查 50 万个候选数
const SIEVE_SIZE: usize = 500_000;
```

### 参数选择依据

- **AMOUNT = 300,000**：充分利用预计算的小素数表，筛掉更多合数
- **SIEVE_SIZE = 500,000**：
  - 足够大，分摊偏移量更新的开销
  - 约 500KB 内存，适配 CPU L3 缓存
  - 提高每个窗口找到安全素数的概率

---

## 性能对比

| 指标 | 原始算法 | 优化后 | 提升 |
|------|----------|--------|------|
| 1536 位安全素数生成 | ~25-30 秒 | ~2.5 秒 | **10 倍+** |
| 大数取模次数 | O(候选数 × 素数数量) | O(素数数量) | 大幅减少 |
| 小素数利用数量 | 135 | 300,000 | 2222 倍 |

---

## 类似的开源实现

这种优化技术在密码学领域是标准做法：

1. **GMP (GNU Multiple Precision)** - `mpz_nextprime` 使用类似的分段筛法
2. **OpenSSL** - `BN_generate_prime_ex` 使用小素数表优化
3. **学术参考**：
   - Joye & Paillier (2003): "Fast Generation of Prime Numbers and Secure Public-Key Cryptographic Parameters"
   - Menezes et al.: "Handbook of Applied Cryptography" Chapter 4

---

## 可能的进一步优化

1. **位向量替代布尔数组**：`Vec<bool>` → `BitVec`，减少 8 倍内存，更好的缓存局部性
2. **预计算模逆元**：`inv(2)` 和 `inv(4)` 只依赖 `p`，可以预存
3. **并行化筛选**：使用 Rayon 并行处理不同的小素数
4. **SIMD 加速**：使用 SIMD 指令批量标记筛表

当前实现已经是生产级别的高性能版本，进一步优化收益递减。
